---
layout: post
title: Here comes the process manager
description: "Jarvis configuration as a service"
tags: [DDD, saga]
author: gianmariaricci
image:
  feature: gears-configuration.jpg
  credit: wonderfulengineering.com
  creditlink: http://wonderfulengineering.com/32-amazing-gear-wallpaper-backgrounds-in-hd-for-download/
comments: true
share: true
---

### A simple situation
Suppose a simple entity that models a folder is a filesystem like architecture; folder creation consist in a single event event called *FolderCreated* and for simplicity lets consider that it is consisted of three single information

- Folder_Id
- ParentFolder_Id
- Name

All Ids are generated by the client and the command to create a Folder is called *CreateFolder* and consists of the above three information. 

Now add another domain operation that consists in a copy of a given folder, and all its subfolders, in another place of the filesystem. This models the concept of a folder template, that represents the basic folder structure you need to store documents related to certain business entities. To avoid people messing up with folder structure, whenever a new business entity is created, the user can ask the system to create a new tree from template to start loading documents.

This sounds really simple in a syncronous architecture, just read the template from the database and duplicate for the new folder. 


###instantiate template 
First implementation was a simple one that accepts a command called *InstantiateTemplate* with a couple of argument, the id of the source folder template and the destination folder.

The system simply read the structure of the template from the corresponding read-model, then it start issuing commands to the system to replicate the structure. Since each folder is an aggregate root, we need to send a series of *CreateFolder* commands. 

Now suppose that the template has that simple id structure (name of the folder is in brackets)

Folder_1 (test)
|--Folder_2 (child1)
|--Folder_3 (child2)

And we want to duplicate this simple structure as a child of another folder with id Folder_4. The handler of the command *InstantiateTemplate* simply reads that structure, and starts generating a command *CreateFolder* like this one

{% highlight json %}
{
	'id' : 'Folder_5',
	'parentId' : 'Folder_4',
    'name' : 'test'
}
{% endhighlight %}

This is the folder corresponding to Folder_1, then it immediately launch another two *CreateFolder* commands to create the childs, something like.

{% highlight json %}
{
	'id' : 'Folder_6',
	'parentId' : 'Folder_5',
    'name' : 'child1'
}

{
	'id' : 'Folder_7',
	'parentId' : 'Folder_5',
    'name' : 'child2'
}
{% endhighlight %}

These three commands will duplicate the simple three folder template in a new part of folder tree.

Do you spot any problem?

###Asyncronous and unordered execution

The above three commands are sent in the command bus but we have two problems.

1. Execution is asyncronous
2. Parallel execution

The first aspect implies that after you launched the first command, to create Folder_5, you does not know when the system will elaborate this command. The second problem is, command execution is multi thread, so the above three command can be executed in parallel.

Do you start to spot any problem?

If everything went good, the system will respond with three *FolderCreated* events, but the order can be anyone. What can happen is that we have this order in the eventstream

1. FolderCreated { 'id' : 'Folder_6', 'parentId' : 'Folder_5' .....
2. FolderCreated { 'id' : 'Folder_5', 'parentId' : 'Folder_4' .....
3. FolderCreated { 'id' : 'Folder_7', 'parentId' : 'Folder_5' .....

Basically you can have creation event of a folder, before the creation event of its father. This problem starts creating errors in projections, because they expect creation events to be raised in logical order.

###If it smells probably you are wrong

Fixing the unordered generation of events in projections is really simple, but we start smelling something in the code. 

The problem is: looking at the above situation, is it possible for the business to have a folder that links to a father that still is not existing? What about if we start adding rules and creation of the father folder will fail, after we created child folder?

The problem arise because we are cheating, the above business operation cannot be handled simply issuing a bunch of command to the handler, but we need a process manager, or saga.

The right way to handle the above situation is changing the FolderCreated command, adding another id that specify the original folder used as a template. This information is needed because the above operation will be implemented witha a process manager that

- listen to the FolderCreated event
- If the event has a TemplateFolderId null it does nothing
- If the event has a non null TemplateFolderId, it find all the child folder of TemplateFolderId, and send to the system a series of *CreateFolder* command to create all the child.

This way to proceed is really better, now the system creates child folder only after the father was created. You can also implement rollback strategies, if some folder cretion error occurred, you can send a delete command for already created folder to return the system in previous state, or you can inform the user that a subtree of the template failed creation, etc.

In a syncronous system you will start with the first *CreateFolder* command, then, once it is finished, if it is successful you can continue sending another command.

In an asyncronous system, if commands are related, you need a process manager that listen to some events and react sending other commands to the system. This sequence of command->events->commands objects is what we usually call a Saga, or a Long Running Operation.

###A simple rule of thumb

When you deal with bus driven asyncronous and multithreadsystem, you need to pay a lot of attention whenever you are implementing a business operation that imply sending multiple commands to the system. 

If every command is completely unrelated by the other one, you can simply send all of them to the bus and forget about order of execution.

If commands are related, as the example of folders creation, you always need some process manager component that orchestrate the operation.

Gian Maria.